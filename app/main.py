import os
import logging
import asyncio
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.responses import RedirectResponse
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from dotenv import load_dotenv
from playwright.async_api import async_playwright

load_dotenv()
logger = logging.getLogger(__name__)

from . import models, schemas, auth
from .database import engine, Base, get_db
from typing import List, Optional
import io
from fastapi.responses import StreamingResponse
from jinja2 import Template

# create DB tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Auth Microservice")

# Enable CORS for frontend requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Change to specific origins in production: ["https://tu-dominio.com"]
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/", include_in_schema=False)
def root():
    """Root route: redirect to documentation (avoids 404 for GET /)."""
    return RedirectResponse(url="/docs")


@app.post("/register", response_model=schemas.UserOut)
def register(user_in: schemas.UserCreate, db: Session = Depends(get_db)):
    existing = auth.get_user_by_email(db, user_in.email)
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    hashed = auth.get_password_hash(user_in.password)
    user = models.User(email=user_in.email, hashed_password=hashed, full_name=user_in.full_name, provider="email")
    db.add(user)
    db.commit()
    db.refresh(user)
    return user


@app.post("/login", response_model=schemas.Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = auth.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=401, detail="Incorrect email or password")
    access_token = auth.create_access_token({"sub": user.email})
    return {"access_token": access_token, "token_type": "bearer"}


@app.post("/google-login", response_model=schemas.Token)
def google_login(payload: schemas.GoogleLogin, db: Session = Depends(get_db)):
    # Client should send an id_token obtained from Google Sign-In
    info = auth.verify_google_token(payload.id_token, audience=os.getenv("GOOGLE_CLIENT_ID"))
    email = info.get("email")
    if not email:
        raise HTTPException(status_code=400, detail="Google token has no email")
    user = auth.get_user_by_email(db, email)
    if not user:
        # Create user with provider 'google'
        user = models.User(email=email, full_name=info.get("name"), provider="google")
        db.add(user)
        db.commit()
        db.refresh(user)
    access_token = auth.create_access_token({"sub": user.email})
    return {"access_token": access_token, "token_type": "bearer"}


@app.get("/me", response_model=schemas.UserOut)
def read_me(current_user: models.User = Depends(auth.get_current_user)):
    return current_user


@app.post("/save-session", response_model=schemas.SessionOut)
def save_session(payload: schemas.SessionCreate, db: Session = Depends(get_db)):
    """Save a session payload generated by the backend or frontend for a user."""
    sess = models.UserSession(user_id=payload.user_id, session_data=payload.session_data)
    db.add(sess)
    db.commit()
    db.refresh(sess)
    return sess


@app.get("/sessions", response_model=List[schemas.SessionOut])
def get_sessions(user_id: Optional[str] = None, db: Session = Depends(get_db)):
    """List sessions. If user_id is provided, filter by that user_id."""
    query = db.query(models.UserSession)
    if user_id:
        query = query.filter(models.UserSession.user_id == user_id)
    results = query.order_by(models.UserSession.created_at.desc()).all()
    return results
